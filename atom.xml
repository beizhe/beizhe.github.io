<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZJ的笔记</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-09-28T16:29:31.436Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zjer</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>原型链</title>
    <link href="http://yoursite.com/2021/09/28/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2021/09/28/%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2021-09-27T16:20:03.675Z</published>
    <updated>2021-09-28T16:29:31.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型"><a href="#原型" class="headerlink" title="#原型"></a>#原型</h2><h3 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h3><p>JavaScript对象是拥有属性和方法的数据，现在创建两个对象</p><p>对象中的<code>[[prototype]]</code>属性即对象的原型，a的原型对象是<code>String</code>，b的…</p><p>同时<code>String</code>，<code>Numbe</code>中也有自己的原型对象<code>Object</code>，直到<code>Object.prototype</code>的原型对象为NULL，这就形成了一条原型链；几乎所有 JavaScript 中的对象都是位于原型链顶端的<code>Object</code>的实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>)</span><br><span class="line"><span class="keyword">var</span> b=<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">666</span>)</span><br><span class="line"><span class="comment">//a的原型链 a ---&gt; String.prototype ---&gt; Object.prototype ---&gt; null</span></span><br></pre></td></tr></table></figure><p>String.prototype定义了<code>indexOf</code>、<code>charAt</code>等方法，因此可以在所有的<code>Array</code>对象上直接调用这些方法</p><p><img src="/2021/09/28/%E5%8E%9F%E5%9E%8B%E9%93%BE/5.PNG" alt="5"></p><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>再看一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.__proto__===<span class="built_in">Function</span>.prototype   <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Function</span>.prototype._proto_===<span class="built_in">Object</span>.prototype  <span class="comment">//true</span></span><br><span class="line"><span class="comment">//原型链  Student ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"><span class="comment">//由于Function.prototype定义了apply()等方法，因此所有的函数都可以调用apply()方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming=<span class="keyword">new</span> Student(<span class="string">'小明'</span>)</span><br><span class="line"></span><br><span class="line">Student.prototype===xiaoming.__proto__  <span class="comment">//true</span></span><br><span class="line">Student.prototype.constructor===Student  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li><p>js分为函数对象和普通对象，每个对象都有一个<strong>[[prototype]]</strong>属性指向原型对象，只有函数对象才有<strong>prototype</strong>属性</p></li><li><p>被构造函数创建的实例对象的 <code>[[Prototype]]</code> 指向 <code>func</code> 的 <code>prototype</code> 属性</p></li><li><p>每个构造函数的原型对象中都包含一个指向构造函数的指针</p><p><img src="/2021/09/28/%E5%8E%9F%E5%9E%8B%E9%93%BE/6.PNG" alt="6"></p></li></ul><h3 id="如何访问原型对象"><a href="#如何访问原型对象" class="headerlink" title="如何访问原型对象"></a>如何访问原型对象</h3><blockquote><p>通过_proto_属性访问（ECMAScript2015将属性 _proto_ 纳入规范的一部分）</p><p>从es5开始，[[prototype]]可以通过Object.getPrototypeOf()和Object.setPrototypeOf()访问器来访问</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype===<span class="built_in">Object</span>.getPrototypeOf(xiaoming) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>一些关于原型对象的方法：</p><ul><li><p><code>instanceof</code>操作符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xiaoming <span class="keyword">instanceof</span> Student <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li><p><code>isPrototypeOf()</code>:判断对象之间是否存中原型关系</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype.isPrototypeOf(xiaoming) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li><p><code>hasOwnProperty()</code>:检测一个属性是存在于实例中还是属性中，只有存在实例中时返回true。注意：并不会检查原型链</p></li></ul><h2 id="原型链"><a href="#原型链" class="headerlink" title="#原型链"></a>#原型链</h2><blockquote><p>假如我们让原型对象等于另一个类型的实例，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。 假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓的原型链的基本概念。</p></blockquote><p>一些特殊情况</p><ul><li><p><code>Function._prototype_</code>是什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.__proto__===<span class="built_in">Function</span>.prototype  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Function.prototype</code>是什么类型？</p><p>Function.prototype是唯一一个typeof XXX.prototype为function的prototype，其它的构造器的prototype都是一个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(<span class="built_in">Function</span>.__proto__)  <span class="comment">//function</span></span><br></pre></td></tr></table></figure></li><li><p><code>Function.prototype.__proto__</code>是什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>Object.prototype.__proto__</code>是什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.__proto__  <span class="comment">//null</span></span><br></pre></td></tr></table></figure><p><img src="/2021/09/28/%E5%8E%9F%E5%9E%8B%E9%93%BE/7.PNG" alt="7"></p></li></ul><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="#原型继承"></a>#原型继承</h2><p>为什么要用原型对象？</p><blockquote><p>使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法</p></blockquote><h3 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student.prototype.age=<span class="number">15</span></span><br><span class="line"><span class="keyword">var</span> xiaofang=<span class="keyword">new</span> Student(<span class="string">'xiaofang'</span>)</span><br><span class="line"></span><br><span class="line">xiaofang.age===xiaoming.age  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><img src="/2021/09/28/%E5%8E%9F%E5%9E%8B%E9%93%BE/8.PNG" alt="8"></p><h3 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h3><h2 id="使用不同的方法创建对象"><a href="#使用不同的方法创建对象" class="headerlink" title="使用不同的方法创建对象"></a>使用不同的方法创建对象</h2><ul><li><p>字面量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1=&#123;<span class="attr">name</span>:<span class="string">'o1'</span>&#125;</span><br><span class="line"><span class="keyword">var</span> o2=<span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span>:<span class="string">'o2'</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>构造函数</p><p>在 JavaScript 中，构造器其实就是一个普通的函数。当使用 new操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f=<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="keyword">this</span>.name=name;&#125;</span><br><span class="line"><span class="keyword">var</span> o3=<span class="keyword">new</span> f(<span class="string">'o3'</span>)</span><br></pre></td></tr></table></figure></li><li><p>Object.create</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p=&#123;<span class="attr">name</span>:<span class="string">'p'</span>&#125;</span><br><span class="line"><span class="comment">// p ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o4=<span class="built_in">Object</span>.create(p)</span><br><span class="line"><span class="comment">// o4 ---&gt; p ---&gt; Object.prototype ---&gt; null</span></span><br><span class="line"><span class="built_in">console</span>.log(o4.name); <span class="comment">// p (继承而来)</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>使用<code>class</code>关键字</p><p>ECMAScript6 引入了一套新的关键字用来实现 <code>class</code>。但JavaScript 仍然基于原型。这些新的关键字包括 <code>class</code>,<code>constructor</code>,<code>extends</code>,<code>static</code> 和 <code>super</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(sideLength) &#123;</span><br><span class="line">    <span class="keyword">super</span>(sideLength, sideLength);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> area() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> sideLength(newLength) &#123;</span><br><span class="line">    <span class="keyword">this</span>.height = newLength;</span><br><span class="line">    <span class="keyword">this</span>.width = newLength;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="#性能"></a>#性能</h2><p>在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链</p><p>遍历对象的属性时，原型链上的<strong>每个</strong>可枚举属性都会被枚举出来。要检查对象是否具有自己定义的属性，而不是其原型链上的某个属性，则必须使用所有对象从 <code>Object.prototype</code> 继承的<code>hasOwnProperty</code>方法，他是 JavaScript 中唯一一个处理属性并且<strong>不会</strong>遍历原型链的方法</p><h2 id="prototype-和-Object-getPrototypeOf"><a href="#prototype-和-Object-getPrototypeOf" class="headerlink" title="prototype 和 Object.getPrototypeOf"></a><code>prototype</code> 和 <code>Object.getPrototypeOf</code></h2><p><code>JavaScript</code>完全是动态的，都是运行时，而且不存在类（class）。所有的都是实例（对象）。即使我们模拟出的 “类”，也只是一个函数对象。</p><p>们的 function A 有一个叫做 <code>prototype</code> 的特殊属性。该特殊属性可与 JavaScript 的 <code>new</code> 操作符一起使用。对原型对象的引用被复制到新实例的内部 <code>[[Prototype]]</code> 属性。例如，当执行 <code>var a1 = new A();</code> 时，JavaScript（在内存中创建对象之后，和在运行函数 <code>A()</code> 把 <code>this</code> 指向对象之前）设置 <code>a1.[[Prototype]] = A.prototype;</code>。然后当您访问实例的属性时，JavaScript 首先会检查它们是否直接存在于该对象上，如果不存在，则会 <code>[[Prototype]]</code> 中查找。这意味着你在 <code>prototype</code> 中定义的所有内容都可以由所有实例有效地共享，你甚至可以稍后更改部分 <code>prototype</code>，并在所有现有实例中显示更改（如果有必要的话）。</p><p>简而言之， <code>prototype</code> 是用于类的，而 <code>Object.getPrototypeOf()</code> 是用于实例的（instances），两者功能一致</p><h2 id="JS-new一个对象的过程"><a href="#JS-new一个对象的过程" class="headerlink" title="JS new一个对象的过程"></a>JS new一个对象的过程</h2><p>1、创建一个新对象</p><p>2、新对象执行[[prototype]]连接</p><p>3、新对象和函数调用的this会绑定起来</p><p>4、执行构造函数中的代码</p><p>5、如果函数没有返回值，那么会自动返回这个对象</p><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;#原型&quot;&gt;&lt;/a&gt;#原型&lt;/h2&gt;&lt;h3 id=&quot;普通对象&quot;&gt;&lt;a href=&quot;#普通对象&quot; class=&quot;headerlink&quot; title=&quot;普通对象&quot;&gt;&lt;/a&gt;普通对象&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2020/07/22/test/"/>
    <id>http://yoursite.com/2020/07/22/test/</id>
    <published>2020-07-22T05:57:41.000Z</published>
    <updated>2021-09-26T12:18:06.070Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/07/22/test/1.PNG" alt="图片"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2020/07/22/test/1.PNG&quot; alt=&quot;图片&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
</feed>
